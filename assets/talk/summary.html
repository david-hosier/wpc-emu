<!DOCTYPE html>
<html>
  <head>
    <title>How to run a 27 years old pinball machine in your browser</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }
      img {
        max-width: 100%;
      }
      /* Two-column layout */
      .left-column {
        color: #777;
        width: 45%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 50%;
        float: right;
        padding-top: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
name: inverse
layout: false
class: center, middle, inverse

# Run a 27 years old Pinball Machine in your browser
2018 by Michael Vogt
.footnote[Go directly to [project site](https://github.com/neophob/wpc-emu)]

???
- Hi Welcome to my talk "Run a 27 years old pinball machine in your browser"

- My name is Michael, during the day I'm working as JS Software developper at NEEO. We're a consumer electronic startup located in bern, solothurn and cuppertino

- at night I sometimes try to emulate old hardware

- the goal of this talk is to show how to build an emulator - that in fact not that hard.

- lets jump to the agenda
---

# Agenda

1. What?

???

- WHAT is a Williams Pinball Machine - how does it look like

--

1. Why?

???

- WHY would someome invest time in emulating an antiquated machine?

--

1. Step-by-Step

???

- Walk through how I build my emulator, will be the biggest part of this talk

--

1. Demo

???

- I'll show how my emulator looks like

--

1. Outlook

???

- What's next? Whats missing?

---
class: center, middle, inverse

# WHAT?

???
- I guess most of you played at least once on a pinball machine

---
# WHAT?

.left-column[
  .left[![](pics/wpc-t2.jpg)]
]

???
- THATS the model i want to emulate
- Williams created different models of their pinball series
- there are total 6 generations
- for now i focus on the second generation of pinball machines - compared to the first version they have a dot matrix display instead of an alphanumeric display

--
.right-column[
### WPC-89 Hardware

- Build in 1991

- CPU Board: 6809 CPU (2MHz), 8kb RAM, Williams ASIC

- Sound Board: 6809 CPU (2MHz), 8kb RAM, Mono output, Sample rate 11KHz

- Dot Matrix Board: drives the 128 x 32 display, 3 different brightness levels, 8kb RAM,
]

???

- Note: ASIC (Application Specific Integrated Circuits), analog and digital functionalities, custom chip

---

# WHAT?

.left-column[
  .left[![](pics/wpc-t2.jpg)]
]

.right-column[
  .left[![](pics/wpc-backbox-removed.jpg)]
]

???
- All electronic boards are installed behind the backbox

---
class: center, middle, inverse

# WHY?

???
- So why should i care about an antiquated machine

---

# WHY?

- I'm fascinated with emulators

???
- ... since I started the first VMWare workstation about 20 years ago
- I always wondered how emulation works

--

- Started a NES Emu last year, canceled

???
- Main reason was the graphics chip is quite complex - so it wasnt compatible with coding while watching Netflix
- There are already plenty of NES Emus around

--

- I recently played on such a Pinball Machine

???
- My oncle own one and I spend quite some time infront of that machine with my son
- Really like that retro sound and nice visuals on the display
- i didn't found another emulator except MAME/PinMAME
- Hardware seems to be simple enough to emulate

---
class: center, middle, inverse

# Step-by-Step

???
- I like starting a new project where you have basically no clue how this damn thing works!

---
background-image: url(pics/fn_skill.jpg)


???
- that image explains very good how i felt after the first hours working on the emulator.

---
# Step-by-Step

- Start the emulator with emulating ...

???
I guess I choosed the only sane option to build a emulator, which is the CPU

---

# Step-by-Step

- Start the emulator with emulating the Motorola 6809 CPU

???
- is an 8-bit microprocessor CPU with some 16-bit features
- produced 1978 - thats 40 years ago!
--

- To use the CPU we need a ROM file

???

- Thanks to MAME most of the pinball machine ROM files are available
- Loading a ROM is straightforward - just load the file into memory
- ROM size is variable, between 128kb and 1mb.
- The files were stored on a hardware EEPROM file, thus its size was definitive a cost factor

--

- After some reasearch I found an existing 6809 CPU emulator written JS

???

- As I already wrote a 6502 CPU emulator for my canceled NES emu - I wasnt sad someone did all the hard work
- Important when writing a CPU emulator are test ROM's. There are plenty of test ROMs available for NES but I couln't find a single one for a williams pinball machine
- Test ROMs will test for example each CPU instruction, validate timing etc.

- Lets get started with the CPU Emu!

---

class: center, middle, inverse

## CPU Emulation

---
## CPU Emulation

Very highlevel a CPU works like this

--

```js
  initialise CPU

  load program into memory

  do

    interrupt handling

    fetch next opcode at current position

    execute opcode and modify CPU state
      optionally fetch more data from current position

    update CPU state

  forever

```

???
- initialise CPU sets its state to a defined state, for example the current position will be defined

- load the program into the CPU memory, so the CPU has something to execute

- interrupt handling TODO

- a CPU opcode is an instruction of the cpu, for example an addition

- the CPU

---
## CPU Emulation

### CPU State

```js
class Cpu6809 {
  constructor(memoryWriteFunction, memoryReadFunction) {
    this.memoryWriteFunction = memoryWriteFunction;
    this.memoryReadFunction = memoryReadFunction;

    this.waitOnInterrupt = false;
    this.irqPendingNMI = false;
    this.irqPendingFIRQ = false;
    this.irqPendingIRQ = false;
    this.tickCount = 0;

    this.regA = 0;
    this.regB = 0;
    this.regX = 0;
    this.regY = 0;
    this.regU = 0;
    this.regS = 0;
    this.regCC = 0;
    this.regPC = 0;
    this.regDP = 0;
  }
```

???
- this model provides function to read and write to memory
- waitOnInterrupt is an explicit state where the cpu waits until a interrupt happen
- the irqPending* flags define if an specific interrupt is pending
- this CPU have 9 registers (???)
- ( 8) A, B -> Accumulators (arithmetic and logic results are stored)
- (16) X, Y -> Index Register
- (16) U: User Stack pointer
- (16) S: System Stack pointer
- (16) PC: Program Counter -> also alled instruction pointer, points to the current instruction in the memory
- ( 8) CC: Condition Code
- ( 8) DP: Direct Page -> there are 10 different address mode the CPU provides, in the direct addressing mode this register contains the upper 8 bits of the addressing mode

---
## CPU API

#### Limited CPU API:
```js
  reset()
  steps(ticks)
  irq()
  clearIrqMasking()
  firq()
  clearFirqMasking()
  nmi()
```

???
- to modify CPU state, the cpu provides this limited API
- reset: set the irq in a defined state
- steps: run cpu instructions for a defined amount of ticks
- set interrupts or clear interrupt masks

--

#### Reset CPU function:

```js
reset() {
  this.regDP = 0;
  this.waitOnInterrupt = false;
  this.irqPendingIRQ = false;
  this.irqPendingFIRQ = false;
  this.irqPendingNMI = false;
  // disable IRQ and FIRQ
  this.regCC = F_IRQMASK | F_FIRQMASK;
  this.regPC = this.ReadWord(vecRESET);
  this.tickCount = 0;
}
```

???
- most important we disable all interrupts
- load the initial vector for the PC register (0xFFFE)
- thats the location where the loaded ROM file boots

---
## CPU Emulation

### Interrupt handling

???

- the part i spend most of the time when i did the NES emulator
- the emulator i use had no interrupt handling included, so i had to implement this

--

```js
// check for pending irq, order or interrupts is important: NMI/FIRQ/IRQ
if (this.irqPendingNMI) {
  this.waitOnInterrupt = false;
  this.irqPendingNMI = false;
  this._executeNmi();
} else if (this.irqPendingFIRQ && (this.regCC & F_FIRQMASK) === 0) {
  this.waitOnInterrupt = false;
  this.irqPendingFIRQ = false;
  this._executeFirq();
} else if (this.irqPendingIRQ && (this.regCC & F_IRQMASK) === 0) {
  this.waitOnInterrupt = false;
  this.irqPendingIRQ = false;
  this._executeIrq();
}

// if there's another irq pending, bail out here
if (this.waitOnInterrupt) {
  console.log('waitOnInterrupt');
  this.tickCount++;
  return 0;
}

```

???

- This CPU provides 3 different interrupt types: NMI, FIRQ, IRQ
- important is that the interrupts have priority, so if multiple interrupts are pending, the most important one is run first
- IRQ and FIRQ can be enabled or disabled (called masking), the NMI interrupt cannot be disabled thus its called non maskble interrupt
- FIRQ is called fast interrupt because this interrupt does not store and restore all registers befor calling the interrupt routine. so this routing must save and load all used registers
- to enable a interrupt, we set the coresponding flag to true

---

## CPU Emulation

### Interrupt handling

```js
_executeIrq() {
  debug('exec irq');
  this.PUSHW(this.regPC);
  this.PUSHW(this.regU);
  this.PUSHW(this.regY);
  this.PUSHW(this.regX);
  this.PUSHB(this.regDP);
  this.PUSHB(this.regB);
  this.PUSHB(this.regA);
  // set ENTIRE flag to this.regCC, used for RTI
  this.regCC |= F_ENTIRE;
  this.PUSHB(this.regCC);
  // Disable interrupts, Set I
  this.regCC |= F_IRQMASK;
  this.regPC = this.ReadWord(vecIRQ);
  this.tickCount += 19;
}

```

???

- save current state

---

## CPU Emulation

### Fetch next opcode

```js
fetch() {
  const v = this.memoryReadFunction(this.regPC++);
  this.regPC &= 0xffff;
  return v;
}

var opcode = this.fetch();
this.tickCount += cycles[opcode];

switch (opcode) {
  case 0x00: //NEG DP
    addr = this.dpadd();
    this.memoryWriteFunction(
      addr,
      this.oNEG(this.memoryReadFunction(addr))
    );
    break;
  case 0x03: //COM DP
    addr = this.dpadd();

  ...

```
???
- after the CPU reset, the CPU will fetch the first instruction using the PC register
- the 6809 CPU provides 59 different instruction
- if the instruction needs parameter, the needed parameter are fetched from the PC register and its offset will be increased
- each of the 59 instructions needs to be implemented

---

## CPU Emulation

### Update CPU State

```js
const cycles = [
  6, 0, 0, 6, 6, 0, 6, 6, 6, 6, 6, 0, 6, 6, 3, 6,  /* 00-0F */
  0, 0, 2, 4, 0, 0, 5, 9, 0, 2, 3, 0, 3, 2, 8, 6,  /* 10-1F */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  /* 20-2F */
  4, 4, 4, 4, 5, 5, 5, 5, 0, 5, 3, 6, 9,11, 0, 19, /* 30-3F */
  2, 0, 0, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2,  /* 40-4F */
  2, 0, 0, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2,  /* 50-5F */
  6, 0, 0, 6, 6, 0, 6, 6, 6, 6, 6, 0, 6, 6, 3, 6,  /* 60-6F */
  7, 0, 0, 7, 7, 0, 7, 7, 7, 7, 7, 0, 7, 7, 4, 7,  /* 70-7F */
  2, 2, 2, 4, 2, 2, 2, 0, 2, 2, 2, 2, 4, 7, 3, 0,  /* 80-8F */
  4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 6, 7, 5, 5,  /* 90-9F */
  4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 6, 7, 5, 5,  /* A0-AF */
  5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 7, 8, 6, 6,  /* B0-BF */
  2, 2, 2, 4, 2, 2, 2, 0, 2, 2, 2, 2, 3, 0, 3, 0,  /* C0-CF */
  4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,  /* D0-DF */
  4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,  /* E0-EF */
  5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6   /* F0-FF */
];

```

???
- each instruction have a specific machine cycles it needs to run
- we use a look up table to increase the tick count
- tick count is important to know how long the cpu is running

---

# Step-by-Step

- load rom
- initialise
- state machine
- opcodes
- irqs
- memory mapping / comm with other periperals
- test


---
class: center, middle, inverse

# Demo

???

- Of course the final asset I showed you before is not made manually

- Here I show you the toolchain I used

---
class: center, middle, inverse

# Outlook

???

My next goals with the Emulator

---
class: center, middle, inverse

# EOF

???

- If you're interessted in realtime generated animations, don't hesitate to visit the Demonights event in the Effinger, there are about 4 Demonights per year

    </textarea>
    <script src="remark/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        navigation: {
          scroll: false
        },
        slideNumberFormat: '',
      });
    </script>
  </body>
</html>
