<!DOCTYPE html>
<html>
  <head>
    <title>How to run a 27 years old pinball machine in your browser</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }
      img {
        max-width: 100%;
      }
      /* Two-column layout */
      .left-column {
        color: #777;
        width: 45%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 50%;
        float: right;
        padding-top: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse
---
name: inverse
layout: false
class: center, middle, inverse

# Run a 27 years old Pinball Machine in your browser
2018 by Michael Vogt
.footnote[Go directly to [project site](https://github.com/neophob/wpc-emu)]

???
- Hi Welcome to my talk "Run a 27 years old pinball machine in your browser"

- My name is Michael, during the day I'm working as Software developper at NEEO. We're a consumer electronic startup located in Bern, Solothurn and Cupertino

- at night I sometimes try to emulate old hardware

- the goal of this talk is to show how to build an emulator - which in fact is not that hard.

- so, lets jump to the agenda
---

# Agenda

1. What?

???

- WHAT is a Williams Pinball Machine - how does it look like

--

1. Why?

???

- WHY would someome invest time in emulating an antiquated machine?

--

1. Build an Emulator, Step-by-Step

???

- Walk through how I build my emulator, will be the biggest part of this talk

--

1. Demo

???

- I'll show how my emulator looks like

--

1. Outlook

???

- What's next? Whats missing?

---
class: center, middle, inverse

# WHAT?

???
- I guess most of you played at least once on a pinball machine

---
# WHAT?

.left-column[
  .left[![](pics/wpc-t2.jpg)]
]

???
- THATS the model i want to emulate - a Williams WPC machine

- there are total 6 generations

- for now i focus on the second generation of pinball machines - compared to the first version they have a dot matrix display instead of an alphanumeric display

--
.right-column[
### WPC-89 Hardware

- Build in 1991

- CPU Board: 6809 CPU (2MHz), 8kb RAM, Williams ASIC

- Sound Board: 6809 CPU (2MHz), 8kb RAM, Mono output, Sample rate 11KHz

- Dot Matrix Board: drives the 128 x 32 display, 3 different brightness levels, 8kb RAM,
]

???

- Note: ASIC (Application Specific Integrated Circuits), analog and digital functionalities, custom chip

---

# WHAT?

.left-column[
  .left[![](pics/wpc-t2.jpg)]
]

.right-column[
  .left[![](pics/wpc-backbox-removed.jpg)]
]

???
- All electronic boards are installed behind the backbox - or Arnies head
- There are dedicated boards
- - the main CPU board
- - Dot matrix display driver
- - An IO board
- - Sound board

A Pinball Machine works quite simple:
- there are **inputs** lines from the mechanical board that go to the IO board that report where the Pinball is using switches.
- there are **output** lines to the mechanical board that light up lamps or activate motors

Note about the Sound board:
- it runs a dedicated 6809 CPU for sound processing
- I didn't fully emulate the Sound board yet - so I won't talk about that board alot

---
class: center, middle, inverse

# WHY?

???
- So why should i care about an antiquated machine

---

# WHY?

- I'm fascinated with emulators

???
- ... since I started the first VMWare workstation about 20 years ago
- I always wondered how emulation works

--

- Started a NES Emu last year, canceled

???
- Main reason was the graphics chip is quite complex - so it wasnt compatible with coding while watching Netflix
- There are already plenty of NES Emus around

--

- I recently played on such a Pinball Machine

???
- My oncle own one and I spend quite some time infront of that machine with my son
- Really like that retro sound and nice visuals on the display
- i didn't found another emulator except MAME/PinMAME
- Hardware seems to be simple enough to emulate

---
class: center, middle, inverse

# Build an Emulator, Step-by-Step

???
- Sooo, lets start with the real stuff!

---
background-image: url(pics/fn_skill.jpg)


???
- thats how i felt after the first hours working on the emulator.

- but i like that when you start on a new project where everything is new and you have no idea.

---
# Step-by-Step

- Start the emulator with emulating ...

???
The only sane option to start a emulator for me was .... anybody?

---

# Step-by-Step

- Start the emulator with emulating the Motorola 6809 CPU

???
- is an 8-bit microprocessor CPU with 16-bit registers

- produced 1978 - thats 40 years ago!
--

- To use the CPU we need a ROM file

???

- Thanks to MAME most of the pinball machine ROM files are available
- Loading a ROM is straightforward - just load the file into memory
- ROM size is variable, between 128kb and 1mb.
- The files were stored on a hardware EEPROM file, thus its size was definitive a cost factor

--

- After some reasearch I found an existing 6809 CPU emulator written JS

???

- As I already wrote a 6502 CPU emulator for my canceled NES emu - I wasnt sad someone did all the hard work
- Important when writing a CPU emulator are test ROM's. There are plenty of test ROMs available for NES but I couln't find a single one for a williams pinball machine
- Test ROMs will test for example each CPU instruction, validate timing etc.

- Lets get started with the CPU Emu!

---

class: center, middle, inverse

## CPU Emulation

---
## CPU Emulation

Very highlevel view how the CPU Emulator works

--

```js
  initialise CPU

  load program into memory

  do

    interrupt handling

    fetch next opcode at current position

    execute opcode and modify CPU state

    update CPU ticks

  forever

```

???
I'll show the concrete examples in the following slides, here's just a quick overview

- first the CPU must be set to a defined state

- then load the program into the memory, so the CPU has something to execute

- then the infinite loop starts

- interrupt handling is useful to react fast on certain events

- execute next opcode - an opcode is an instruction of the cpu, for example an mathematical addition

- add the end we update the CPU ticks to know what the CPU executed, important for time sync

---
## CPU Emulation

### CPU State

```js
class Cpu6809 {
  constructor(memoryWriteFunction, memoryReadFunction) {
    this.memoryWriteFunction = memoryWriteFunction;
    this.memoryReadFunction = memoryReadFunction;

    this.waitOnInterrupt = false;
    this.irqPendingNMI = false;
    this.irqPendingFIRQ = false;
    this.irqPendingIRQ = false;
    this.tickCount = 0;

    this.regA = 0;
    this.regB = 0;
    this.regX = 0;
    this.regY = 0;
    this.regU = 0;
    this.regS = 0;
    this.regCC = 0;
    this.regPC = 0;
    this.regDP = 0;
  }
```

???
- This is more or less the CPU state

- this model provides function to read and write to memory
- waitOnInterrupt is an explicit state where the cpu waits until a interrupt happen
- the irqPending* flags define that a specific interrupt is pending
- this CPU have 9 registers (???)
- ( 8) A, B -> Accumulators (arithmetic and logic results are stored)
- (16) X, Y -> Index Register, usually contain an index used for indexed addressing modes
- (16) U: User Stack pointer, The user stack is usually used to pass arguments to/from subroutines, and it can also be used for temporary data storage
- (16) S: System Stack pointer, The system stack stores machine state during subroutine calls and interrupts.
- (16) PC: Program Counter -> register pointing to the next instruction that will be executed by the CPU
- ( 8) CC: Condition Code -> contains the flags, for example to mask FIRQ and IRQ, entire flag used when returning from an interrupt to restore the correct data of the registers
- ( 8) DP: Direct Page -> there are 10 different address mode the CPU provides, in the direct addressing mode this register contains the most significant byte of the zero page address



---
## CPU API

#### Limited CPU API:
```js
  reset()
  steps(ticks)
  irq()
  clearIrqMasking()
  firq()
  clearFirqMasking()
  nmi()
```

???
to work with the CPU, it provides this limited API
- reset: set the CPU in a defined state
- steps: run cpu instructions for a defined amount of ticks
- set interrupts or clear interrupt masks

Resetting the CPU looks simple as
--

#### Reset CPU function:

```js
reset() {
  this.regDP = 0;
  this.waitOnInterrupt = false;
  this.irqPendingIRQ = false;
  this.irqPendingFIRQ = false;
  this.irqPendingNMI = false;
  // disable IRQ and FIRQ
  this.regCC = F_IRQMASK | F_FIRQMASK;
  this.regPC = this.ReadWord(vecRESET);
  this.tickCount = 0;
}
```

???
- most important we disable all interrupts
- load the initial vector for the PC register (0xFFFE) - thats the location where the loaded ROM file boots
- there are other hardcoded address spaces, for example all the IRQ routines can be found at 0xFFF6, 0xFFF8 and 0xFFFC

---
## CPU Emulation

### Interrupt handling

???

- the part i spend most of the time when i did the NES emulator
- the emulator i use had no interrupt handling included, so i had to implement this

--

```js
// check for pending irq, order or interrupts is important: NMI/FIRQ/IRQ
if (this.irqPendingNMI) {
  this.waitOnInterrupt = false;
  this.irqPendingNMI = false;
  this._executeNmi();
} else if (this.irqPendingFIRQ && (this.regCC & F_FIRQMASK) === 0) {
  this.waitOnInterrupt = false;
  this.irqPendingFIRQ = false;
  this._executeFirq();
} else if (this.irqPendingIRQ && (this.regCC & F_IRQMASK) === 0) {
  this.waitOnInterrupt = false;
  this.irqPendingIRQ = false;
  this._executeIrq();
}

// if there's another irq pending, bail out here
if (this.waitOnInterrupt) {
  console.log('waitOnInterrupt');
  this.tickCount++;
  return 0;
}

```

???

- This CPU provides 3 different interrupt types: NMI, FIRQ, IRQ
- important is that the interrupts have priority, so if multiple interrupts are pending, the most important one is run first
- IRQ and FIRQ can be enabled or disabled (called masking), the NMI interrupt cannot be disabled thus its called non maskble interrupt
- FIRQ is called fast interrupt because this interrupt does not store and restore all registers befor calling the interrupt routine. so this routing must save and load all used registers
- to enable a interrupt, we set the coresponding flag to true

---

## CPU Emulation

### Interrupt handling

```js
_executeIrq() {
  debug('exec irq');
  this.PUSHW(this.regPC);
  this.PUSHW(this.regU);
  this.PUSHW(this.regY);
  this.PUSHW(this.regX);
  this.PUSHB(this.regDP);
  this.PUSHB(this.regB);
  this.PUSHB(this.regA);
  // set ENTIRE flag to this.regCC, used for RTI
  this.regCC |= F_ENTIRE;
  this.PUSHB(this.regCC);
  // Disable interrupts, Set I
  this.regCC |= F_IRQMASK;
  this.regPC = this.ReadWord(vecIRQ);
  this.tickCount += 19;
}

```

???

- save current state

---

## CPU Emulation

### Fetch next opcode

```js
fetch() {
  const v = this.memoryReadFunction(this.regPC++);
  this.regPC &= 0xffff;
  return v;
}

var opcode = this.fetch();
this.tickCount += cycles[opcode];

switch (opcode) {
  case 0x00: //NEG Direct Page
    addr = this.dpadd();
    this.memoryWriteFunction(addr, this.oNEG(this.memoryReadFunction(addr)));
    break;
  case 0x03: //COM DP
    addr = this.dpadd();

  ...

```
???
- after the CPU reset, the CPU will fetch the next instruction using the PC register
- the 6809 CPU provides 59 different instruction
- there's a Instruction Sets manual for each CPU that explains what each opcode does
- if the instruction needs parameter, the needed parameter are fetched from the PC register and its offset will be increased
- each of the 59 instructions needs to be implemented

---

## CPU Emulation

### Update CPU State

```js
const cycles = [
  6, 0, 0, 6, 6, 0, 6, 6, 6, 6, 6, 0, 6, 6, 3, 6,  /* 00-0F */
  0, 0, 2, 4, 0, 0, 5, 9, 0, 2, 3, 0, 3, 2, 8, 6,  /* 10-1F */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  /* 20-2F */
  4, 4, 4, 4, 5, 5, 5, 5, 0, 5, 3, 6, 9,11, 0, 19, /* 30-3F */
  2, 0, 0, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2,  /* 40-4F */
  2, 0, 0, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2,  /* 50-5F */
  6, 0, 0, 6, 6, 0, 6, 6, 6, 6, 6, 0, 6, 6, 3, 6,  /* 60-6F */
  7, 0, 0, 7, 7, 0, 7, 7, 7, 7, 7, 0, 7, 7, 4, 7,  /* 70-7F */
  2, 2, 2, 4, 2, 2, 2, 0, 2, 2, 2, 2, 4, 7, 3, 0,  /* 80-8F */
  4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 6, 7, 5, 5,  /* 90-9F */
  4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 6, 7, 5, 5,  /* A0-AF */
  5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 7, 8, 6, 6,  /* B0-BF */
  2, 2, 2, 4, 2, 2, 2, 0, 2, 2, 2, 2, 3, 0, 3, 0,  /* C0-CF */
  4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,  /* D0-DF */
  4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,  /* E0-EF */
  5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6   /* F0-FF */
];

```

???
- each instruction have a specific machine cycles it needs to run
- we use a look up table to increase the tick count
- tick count is important to know how long the cpu is running

---

## CPU Emulation

### Can I run a ROM now?

???
- CPU Emulation is implemented, does that mean I can run my ROM?

--

.center[![](pics/fn_no.jpg)]

???
- a pretty clear NO!

- Why? The ROM expects that other hardware can be accessed. Thats not really possible now, so either we wait forever - maybe because an interrupt is not triggered - or the program crashes.

-

---

class: center, middle, inverse

## Communicate with other peripherals

???
- So how can the CPU communicate with other periperals?

- Devices can communicate with the CPU using the interrupts - see the exposed CPU API

- The CPU can use the injected memory read/write functions to communicate with devices, called memory mapping or memory mapper io.

---
## Communicate with other peripherals

### Memory-mapped I/O (MMIO)

???
- Memory Mapped IO is a hardware feature build in the CPU

--
The CPU has access to an address space of 64kb (16 bit).

???
- our system has only 8kb RAM, so what to do with 64kb?
- the answer is: we can communicate with other hardware

--

The memory map of the WPC-89 Hardware looks like this:

- $0000-$1FFF (8kb)	RAM

???
- The memory map is static
- communicate with RAM should be pretty clear

--
- $2000-$3FFF (8kb)	Hardware

???
- There is an 8kb address space reserved to communicate with the **Hardware**
- Examples: Dot Matrix Controller, Sound Controller, Lamp output, Switch input, Bankswitched region...

--
- $4000-$7FFF (16kb) Bankswitched ROM (paging area) - READ ONLY
???
- **Bankswitched ROM**: Wikipedia describe Bank switching as: "Bank switching is a technique used in computer design to increase the amount of usable memory beyond the amount directly addressable by the processor"
- the ROM file can be up to 1MB size - Bankswitching means to access parts of the ROM, the ROM is divided into 16kb junks (maximal 64 junks if the ROM is 1MB)

--

- $8000-$FFFF (32kb) Non-bankswitched "System ROM"

???
- **System ROM** is the last 32kb of the ROM and per definition the bootable part, aka the OS.
- The OS is called Apple which means "Advanced Pinball Programming Logic Executive" and is always available

---
## Communicate with other peripherals

### Read Memory implementation

Implementation of the memory read function
--

```js
  _read8(offset) {
    const address = memoryMapper.getAddress(offset);
    switch (address.subsystem) {

      case memoryMapper.SUBSYSTEM_RAM:
        return this.ram[address.offset];

      case memoryMapper.SUBSYSTEM_HARDWARE:
        return this._hardwareRead(address.offset);

      case memoryMapper.SUBSYSTEM_BANKSWITCHED:
        return this._bankswitchedRead(address.offset);

      case memoryMapper.SUBSYSTEM_SYSTEMROM:
        return this.systemRom[address.offset];

      default:
        throw new Error('INVALID_READ_SUBSYSTEM');
    }
  }
```

???
- thats the function the CPU uses when a byte is loaded from the "memory"

- the memoryMapper returns which subsystem the read function is responsible and delegates the function to it.

---

## ASIC Emulation

???
- TODO

---

## Timing

One of the key elements of our Emulator

--

### CPU Requirements

- The CPU runs at 2 MHz

???
- this means the CPU can execute 2 Million ticks per second

--

- Execute approx. 350'000 operations per seconds

???
- DONT use debug statements if your Emulator should run at a decent framerate!

--

- Interrupts relies on exact timing

???
- If an interrupts is fired to late or early our program might crash or stuck forever

---

## Timing

#### Mainloop of the Emulator

???
To fulfill the requirements, I expose one function that executes several ticks

--
```js
executeCycle(ticksToRun, tickSteps) {
  let ticksExecuted = 0;
  while (ticksExecuted < ticksToRun) {
    const singleTicks = this.cpu.steps(tickSteps);
    ticksExecuted += singleTicks;
    this.ticksIrq += singleTicks;
    if (this.ticksIrq >= timing.CALL_IRQ_AFTER_TICKS) {
      this.ticksIrq -= timing.CALL_IRQ_AFTER_TICKS;
      this.cpu.irq();
    }

    this.ticksUpdateDmd += singleTicks;
    if (this.ticksUpdateDmd >= timing.CALL_WPC_UPDATE_DISPLAY_AFTER_TICKS) {
      this.ticksUpdateDmd -= timing.CALL_WPC_UPDATE_DISPLAY_AFTER_TICKS;
      this.dmdBoard.copyScanline();
    }

    this.cpuBoardAsic.executeCycle(singleTicks);
  }

  this.soundBoard.executeCycle(ticksToRun, tickSteps);
  return ticksExecuted;
}
```

???
- TODO explain ticksToRun, tickSteps

---

class: center, middle, inverse

# Demo

???

- Of course the final asset I showed you before is not made manually

- Here I show you the toolchain I used

---
class: center, middle, inverse

# Outlook

-
???

My next goals with the Emulator
- Buy a real Williams Pinball machine
- Replace main CPU Board and Dot Matrix Display Controller with a RPi
- Use input switches as trigger

---
class: center, middle, inverse

# EOF

???

- Thats it, thanks for listening.
- Questions?

    </textarea>
    <script src="remark/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        navigation: {
          scroll: false
        },
        slideNumberFormat: '',
      });
    </script>
  </body>
</html>
